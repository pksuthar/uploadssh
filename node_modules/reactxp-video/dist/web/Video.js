"use strict";
/*
* Video.tsx
*
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the MIT license.
*
* Web-specific implementation of the cross-platform Video abstraction.
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var extend = require("lodash/extend");
var React = require("react");
var RX = require("reactxp");
var ReactDOM = require("react-dom");
var _styles = {
    defaultStyle: {
        display: 'flex'
    }
};
var Video = /** @class */ (function (_super) {
    __extends(Video, _super);
    function Video() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._onLoadedData = function () {
            if (_this.props.onLoadedData) {
                var videoDOM = ReactDOM.findDOMNode(_this);
                if (videoDOM) {
                    var loadInfo = {
                        duration: videoDOM.duration,
                        naturalSize: {
                            width: videoDOM.videoWidth,
                            height: videoDOM.videoHeight
                        }
                    };
                    _this.props.onLoadedData(loadInfo);
                }
            }
        };
        _this._onTimeUpdate = function () {
            if (_this.props.onProgress) {
                var videoDOM = ReactDOM.findDOMNode(_this);
                if (videoDOM) {
                    _this.props.onProgress({
                        currentTime: videoDOM.currentTime,
                        playableDuration: videoDOM.duration
                    });
                }
            }
        };
        return _this;
    }
    Video.prototype.componentDidMount = function () {
        var _this = this;
        // We need to manually install the onEnded handler because. React doesn't support this.
        var videoDOM = ReactDOM.findDOMNode(this);
        videoDOM.onended = function () {
            if (_this.props.onEnded) {
                _this.props.onEnded();
            }
        };
    };
    Video.prototype.componentWillUnmount = function () {
        var videoDOM = ReactDOM.findDOMNode(this);
        if (videoDOM) {
            // Prevent Chrome based browsers  to leak video elements
            videoDOM.src = '';
        }
    };
    Video.prototype.render = function () {
        var combinedStyles = RX.Styles.combine([_styles.defaultStyle, this.props.style]);
        if (this.props.resizeMode === 'cover') {
            combinedStyles = extend(combinedStyles, {
                position: 'absolute',
                minWidth: '100%',
                minHeight: '100%',
                width: 'auto',
                height: 'auto',
                top: '50%',
                left: '50%',
                WebkitTransform: 'translate(-50%,-50%)',
                MozTransform: 'translate(-50%,-50%)',
                msTransform: 'translate(-50%,-50%)',
                transform: 'translate(-50%,-50%)'
            });
        }
        else if (this.props.resizeMode === 'contain') {
            combinedStyles = extend(combinedStyles, {
                width: '100%',
                height: '100%'
            });
        }
        else {
            combinedStyles = extend(combinedStyles, {
                width: 'auto',
                height: 'auto',
                maxWidth: '100%',
                maxHeight: '100%'
            });
        }
        return (React.createElement("video", { ref: 'video', style: combinedStyles, src: this.props.source, alt: this.props.accessibilityLabel, controls: this.props.showControls, loop: this.props.loop, onLoadedData: this._onLoadedData, onError: this.props.onError, onEnded: this.props.onEnded, onLoadStart: this.props.onLoadStart, onCanPlay: this.props.onCanPlay, onCanPlayThrough: this.props.onCanPlayThrough, onTimeUpdate: this.props.onProgress ? this._onTimeUpdate : null }));
    };
    Video.prototype.seek = function (position) {
        var videoDOM = ReactDOM.findDOMNode(this);
        if (videoDOM) {
            videoDOM.currentTime = position;
        }
    };
    Video.prototype.seekPercent = function (percentage) {
        var videoDOM = ReactDOM.findDOMNode(this);
        if (videoDOM) {
            videoDOM.currentTime = percentage * videoDOM.duration;
        }
    };
    Video.prototype.play = function () {
        var videoDOM = ReactDOM.findDOMNode(this);
        if (videoDOM) {
            videoDOM.play();
        }
    };
    Video.prototype.pause = function () {
        var videoDOM = ReactDOM.findDOMNode(this);
        if (videoDOM) {
            videoDOM.pause();
        }
    };
    Video.prototype.stop = function () {
        var videoDOM = ReactDOM.findDOMNode(this);
        if (videoDOM) {
            videoDOM.pause();
            videoDOM.currentTime = 0;
        }
    };
    Video.prototype.mute = function (muted) {
        var videoDOM = ReactDOM.findDOMNode(this);
        if (videoDOM) {
            videoDOM.muted = muted;
        }
    };
    return Video;
}(RX.Component));
exports.default = Video;
